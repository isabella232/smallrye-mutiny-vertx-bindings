package io.vertx.mutiny.mqtt;

import static org.hamcrest.CoreMatchers.is;
import static org.hamcrest.CoreMatchers.notNullValue;
import static org.hamcrest.MatcherAssert.assertThat;

import org.junit.*;
import org.testcontainers.containers.BindMode;
import org.testcontainers.containers.GenericContainer;
import org.testcontainers.containers.wait.strategy.Wait;

import io.netty.handler.codec.mqtt.MqttConnectReturnCode;
import io.vertx.mqtt.MqttClientOptions;
import io.vertx.mutiny.core.Vertx;
import io.vertx.mutiny.mqtt.messages.MqttConnAckMessage;

public class MqttClientTest {

    @ClassRule
    public static GenericContainer<?> mosquitto = new GenericContainer<>("eclipse-mosquitto:2.0")
            .withExposedPorts(1883)
            .withClasspathResourceMapping("mosquitto.conf", "/mosquitto/config/mosquitto.conf", BindMode.READ_ONLY)
            .waitingFor(Wait.forLogMessage(".*mosquitto .* running.*", 1));
    private Vertx vertx;

    @Before
    public void setUp() {
        vertx = Vertx.vertx();
        assertThat(vertx, is(notNullValue()));
    }

    @After
    public void tearDown() {
        vertx.closeAndAwait();
    }

    @Test
    public void test() {
        MqttClient client = MqttClient.create(vertx, new MqttClientOptions().setAutoGeneratedClientId(true));
        MqttConnAckMessage connection = client
                .connect(mosquitto.getMappedPort(1883), mosquitto.getContainerIpAddress())
                .await().indefinitely();
        assertThat(connection, is(notNullValue()));
        assertThat(connection.code(), is(MqttConnectReturnCode.CONNECTION_ACCEPTED));
        client.disconnectAndAwait();
    }

}
